<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/**********************************************************************
 * This code was generated by a tool.                                 *
 * Please do not modify this file directly - modify Tokens.tt instead *
 **********************************************************************/
using System;
using System.Diagnostics;

namespace ClrDebug
{
<#
var types = new[]
{
    "mdToken",
    "mdModule", //Represents a module, which is generally a metadata scope
    "mdTypeRef", //Represents a reference to a type in either the current or another metadata scope
    "mdTypeDef", //Represents a type defined in the current metadata scope
    "mdFieldDef", //Represents a field defined in the current metadata scope
    "mdMethodDef", //Represents a method defined in the current metadata scope
    "mdParamDef", //Represents a method parameter
    "mdInterfaceImpl", //Represents an interface implementation, which can be used to find the interface and struct/class that are partaking in the implementation
    "mdMemberRef", //Represents a type member typed in the current or another metadata scope
    "mdCustomAttribute", //Represents an attribute defined on a type, member or parameter
    "mdPermission",
    "mdSignature",
    "mdEvent",
    "mdProperty", //Represents a property token
    "mdModuleRef",
    "mdAssembly", //Represents the current assembly
    "mdAssemblyRef", //Represents an external assembly reference
    "mdFile",
    "mdExportedType", //Represents a forwarded type
    "mdManifestResource",
    "mdTypeSpec",
    "mdGenericParam", //Represents a generic parameter of a type or method.
    "mdMethodSpec",
    "mdGenericParamConstraint",
    "mdString",
    "mdCPToken"
};

for(int i = 0; i < types.Length; i++)
{
    var type = types[i];

    if (type == "mdToken")
    {
#>
    [Serializable]
    [DebuggerDisplay("{ToString(),nq} [{Type}]")]
<#
    }
    else
    {
#>
    [Serializable]
    [DebuggerDisplay("{ToString(),nq} [<#= type #>]")]
<#
    }
#>
    public struct <#= type #> : IComparable, IEquatable<<#= type #>>
    {
        <#
            if(type == "mdToken")
            {
        #>
public static readonly <#= type #> Nil = new <#= type #>();
        <#
                WriteLine("");
            }
            else if(type != "mdCPToken")
            {
        #>
public static readonly <#= type #> Nil = new <#= type #>((uint) CorTokenType.<#= type.Insert(2, "t") #>);
        <#
                WriteLine("");
            }
        #>
        /// <summary>
        /// Gets the Row ID of the metadata token.
        /// </summary>
        public int Rid => (int) Value & 0x00FFFFFF;

        public CorTokenType Type => (CorTokenType) (Value & 0xFF000000);

        /// <summary>
        /// Gets the raw numeric value of the metadata token.
        /// </summary>
        public uint Value { get; }

        public bool IsNil => Rid == 0;

        public <#= type #>(uint value)
        {
            Value = value;
        }

        public <#= type #>(int value) : this((uint) value)
        {
        }

        public static implicit operator int(<#= type #> value) => (int) value.Value;

        public static implicit operator uint(<#= type #> value) => value.Value;

        public static implicit operator <#= type #>(int value) => new <#= type #>(value);

        public static implicit operator <#= type #>(uint value) => new <#= type #>(value);

<#
    if(type == "mdToken")
    {
        for(var j = 1; j < types.Length; j++)
        {
            if (types[j] == "mdCPToken")
                continue;
#>
        public static explicit operator <#= types[j] #>(<#= type #> value)
        {
            if (value.Type != CorTokenType.<#= (types[j]).Insert(2, "t") #>)
                throw new InvalidOperationException($"Cannot cast a value of type '{value.Type}' to a token of type '<#= types[j] #>'.");

            return new <#= types[j] #>(value.Value);
        }
<#
            if (j < types.Length - 1)
                WriteLine("");
        }
    }
    else
    {
#>
        public static implicit operator mdToken(<#= type #> value) => new mdToken(value.Value);

<#
    }
#>
        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo(Value, value is <#= type #> v ? v.Value : value);

        public bool Equals(<#= type #> other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public static bool operator ==(<#= type #> left, <#= type #> right) => left.Value == right.Value;

        public static bool operator !=(<#= type #> left, <#= type #> right) => left.Value != right.Value;

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }
<#
if (i < types.Length - 1)
    WriteLine("");
}
#>
}