<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/************************************************************************
 * This code was generated by a tool.                                   *
 * Please do not modify this file directly - modify Types.tt instead    *
 ***********************************************************************/
using System;
using System.Diagnostics;

namespace ClrDebug.PDB
{
<#
var types = new[]
{
    Tuple.Create("CV_typ16_t", "short"),
    Tuple.Create("CV_off16_t", "short"),
    Tuple.Create("CV_uoff16_t", "short"),

    Tuple.Create("CV_typ_t", "int"), //CV_typ_t is the name given to this type within CodeView, however PDB1 aliases this to "TI". It's exactly the same thing however, and so would be confusing to have both concepts
    Tuple.Create("CV_off32_t", "int"),
    Tuple.Create("CV_uoff32_t", "int"),
    Tuple.Create("CV_ItemId", "int"),
};

for(int i = 0; i < types.Length; i++)
{
    var type = types[i].Item1;
    var baseType = types[i].Item2;

if (type == "CV_typ_t")
{
#>
    /// <summary>
    /// Represents a 32-bit type index. This type is also known as "TI" within PDB1.
    /// </summary>
<#
}
else if (type == "CV_typ16_t")
{
#>
    /// <summary>
    /// Represents a 16-bit type index. This type is also known as "TI16" within PDB1.
    /// </summary>
<#
}
#>
    [Serializable]
    [DebuggerDisplay("{Value}")]
    public struct <#= type #> : IComparable, IEquatable<<#= type #>>
    {
        public <#= baseType #> Value { get; }

        public <#= type #>(<#= baseType #> value)
        {
            Value = value;
        }

        public static implicit operator <#= baseType #>(<#= type #> value) => value.Value;

        public static implicit operator <#= type #>(<#= baseType #> value) => new <#= type #>(value);

<#
//Numeric literals are implicitly integers; as such, without an implicit conversion from int -> wrapper type,
//we can't assign a numeric literal to a parameter expecting a wrapper type
if (baseType != "int")
{
#>
        public static implicit operator <#= type #>(int value) => new <#= type #>((<#= baseType #>) value);

<#
}
#>
        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo((ulong) Value, value is <#= type #> v ? v.Value : value);

        public bool Equals(<#= type #> other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public static bool operator ==(<#= type #> left, <#= type #> right) => left.Value == right.Value;

        public static bool operator ==(<#= type #> left, int right) => left.Value == (<#= baseType #>) right;

        public static bool operator !=(<#= type #> left, <#= type #> right) => left.Value != right.Value;

        public static bool operator !=(<#= type #> left, int right) => left.Value != (<#= baseType #>) right;

        public override int GetHashCode() => Value.GetHashCode();
    }
<#
if (i < types.Length - 1)
    WriteLine("");
}
#>
}